# 第四周作业

## 第七课 Java并发编程(2)

1. （**选做**）把示例代码，运行一遍，思考课上相关的问题。也可以做一些比较。 

   > DaemonThread

   ​	当主线程结束时，守护线程会自动关闭。

   > OnlyMain

   ​	简单的启动一个main函数，会有6个进程被创建，如下所示：

   ```
   [6] Monitor Ctrl-Break
   
   	调用线程控制中断，停止当前线程及子线程。
   	
   [5] Attach Listener
   
   	Attach Listener线程是负责接收到外部的命令，而对该命令进行执行的并且把结果返回给发送者。通常我们会用一些命令去要求jvm给我们一些反馈信息，如：java -version、jmap、jstack等等。如果该线程在jvm启动的时候没有被初始化，则会在用户第一次执行jvm命令时启动。
   	
   [4] Signal Dispatcher
   
   	Attach Listener线程的职责是接收外部jvm命令，当命令接收成功后，会交给Signal Dispather线程去进行分发到各个不同的模块处理命令，并且返回处理结果。Signal Dispather线程也是在第一次接收到外部jvm命令时，进行初始化工作的。
   	
   [3] Finalizer
   
   	这个线程也是在main线程之后创建的，其优先级为10，主要用于在垃圾收集前，调用对象的finalize()方法；关于Finalizer线程的几点：
       1. 只有当开始一轮垃圾收集时，才会开始调用finalize()方法；因此并不是所有对象的finalize()方法都会被执行；
   	2. 该线程也是daemon线程，因此如果虚拟机中没有其他非daemon线程，不管该线程有没有执行完finalize()方法，JVM也会退出；
   	3. JVM在垃圾收集时会将失去引用的对象包装成Finalizer对象（Reference的实现），并放入ReferenceQueue，由Finalizer线程来处理；最后将该Finalizer对象的引用置为null，由垃圾收集器来回收；
   	4. JVM为什么要单独用一个线程来执行finalize()方法呢？如果JVM的垃圾收集线程自己来做，很有可能由于在finalize()方法中误操作导致GC线程停止或不可控，这对GC线程来说是一种灾难。
   	
   [2] Reference Handler
   
   	JVM在创建main线程后就创建Reference Handler线程，其优先级为10，它主要用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收问题。
   	
   [1] main
   	主线程
   ```

   

2. （**必做**）思考有多少种方式，在main函数启动一个新线程，运行一个方法，拿到这 

个方法的返回值后，退出主线程？ 

​		1

## 第八课 Java并发编程(3)

1. （**选做**）列举常用的并发操作 API 和工具类，简单分析其使用场景和优缺点。

   1

2. （**选做**）请思考：什么是并发？什么是高并发？实现高并发高可用系统需要考虑哪些

因素，对于这些你是怎么理解的？ 

​		1

3. （**选做**）请思考：还有哪些跟并发类似/有关的场景和问题，有哪些可以借鉴的解决

办法。

​		1

4. （**必做**）把多线程和并发相关知识带你梳理一遍，画一个脑图，截图上传到 Github

上。

​		1